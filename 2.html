<!doctype html>
<html>
<head>
	<title>WEB2 - CSS</title>
	<meta charset="utf-8">
	<link rel="stylesheet" href = "style.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<script src = "colors.js"> </script>
</head>

<body>
	<h1> <a href="index.html">WEB	</a></h1>	
	<input id = "night_day" type="button" value="night" onclick= "
		nightdayHandler(this);
	">
	<div id="grid">

		<ol id = "contents">
			&lt; Contents &gt;
			<li><a href="1.html">HTML </a></li>
			<li><a href="2.html">CSS </a></li>
			<li><a href="3.html">JavaScript </a></li>
		</ol>
		
		<div id="article">
			<h2> CSS</h2>
			<h3>
				1. CSS 등장 이전의 상황
			</h3>
			<h4>
				#디자인의 필요성이 대두됨
			</h4>
			<h5>
				방법 1. HTML에 새로운 태그(디자인 기능)을 추가시킴
			</h5>
				한계 1. HTML은 정보를 담아야 하는데, 디자인까지 담게되어 가치가 떨어짐. <br>
			2. 여러개의 디자인을 바꾸기에 번거로움
			<h5>
				새로운 언어(CSS)를 개발.
			</h5>
						+ 웹브라우저 입장에서는 font(방법1)을 쓰는게 편하다. <br>
			그럼에도 css를 사용하는 이유는 (한계1, 2)를 해결할 수 있기 때문이다. <br>
			
			+코딩을 잘하는 방법 : 중복의 제거
			<br>font태그 n개 -> a태그 1개로 중복 제거 가능
			<br>css가 유지보수가 용이 and 가독성이 뛰어남
			<h3>
				2. CSS의 등장
			</h3>
			<h4>
				#HTML에서의 공백 처리 방법: &lt;!--여기의 내용이 공백처리 됨 --> <br> </h4>
			<h4>
				
				#&lt;style> &lt;/style> 사이에 css문법이 있음을 html문법으로 알려준다. <br>
				
			</h4>
			ex)  <br>
			&lt;style> <br>
				a { color: red; }	 <br>
			&lt;/style> <br><br>
			
			<h3>
				3. CSS의 등장배경
			</h3>
			+1.HTML의 디자인 기능을 CSS가 분담 <br>
			+2. CSS가 하는 것이 개발자 입장에서 효율적
			<h3>
				4. 혁명적 변화
			</h3>
			<h4>
				# HTML 태그를 이용하여 색깔을 바꾸기 [인라인]
			</h4>
			style 속성 : &lt;a style= "color = red"> <br>
			
			<h4>
				#CSS를 이용하여 색깔을 바꾸기
			</h4>
				+ a : 선택자 {selector} <br><br>
				+ {} : 선언 {declaration}<br><br>
				<img src="css.png" width= "70%"> <br><br>
			<h4>
				#CSS를 이용하여 밑줄을 추가 및 제거 하기
			</h4>
				+ {text-decoration : none or underline;} <br><br>
			<h3>
				5. CSS 속성 스스로 알아내기
			</h3>
			<h4>
				#검색
			</h4>
			<h5>
				검색할 방법만 알면 1분안에 찾을 수 있다. 이는 아는것과 다름 없다.<br><br>
				+ CSS {찾고자하는 기능} property 검색 <br><br>
				ex) [CSS text align property ]
			</h5>
			<h4>
				#정렬기능 (Align)
			</h4>
			{text-align : center; } : 중앙정렬
			<h3>
				6. CSS 선택자 스스로 알아내기
			</h3>
			<h4>
				#하고자 하는 것들
			</h4>
			0. 리스트에서, <br><br>
			1. 기본 : 검정 <br><br>
			2. 방문했던 것들 : 회색 <br><br>
			3. 방문 중 : 빨강 <br><br>
			<h4>
				#기존에는 일일이 인라인을 했어야 했지만, CSS에서는 class와 id를 이용하여 편리하게 해결할 수 있다.
			</h4>
			<h5>
				&lt; a class = "saw"> 1.html <br><br>
				-> .saw{color : gray;}
			</h5>
			<h5>
				&lt; a class = "saw active"> 2.html <br><br>
				.active { color:gray;} <br><br>
				active가 나중에 등장 -> 나중에 적용된다. -> 우선순위가 높다.
				
			</h5>
			<h5>
				&lt; a class = "saw" id = "active"> 2.html
			</h5>
				#active {color : gray;} <br><br>
				id > class >tag 순으로 우선순위가 높다 (특수한 것들이 높음.) 
			<h3>
				7. 박스모델
			</h3>
			<h4>
				h1,a 태그를 걸면 줄바꿈이 안된다. 이는 두 태그의 크기가 정해져 있기 때문이다. 그렇다면 두 태그의 크기를 어떻게 알 수 있을까?
			</h4>
			<h5>
				#Property
			</h5>
			+ border-width: 테두리 두께 조정 <br><br>
			+ border-color: 테두리 색깔 조정 <br><br>
			+ border-style: 테두리 속성 조정 (단선 :solod, 점선 : dotted ) <br><br>
			+ paddig: 컨텐츠-테두리 사이의 간격 조정 <br><br>
			+ margin: 테두리 사이 간격 조정 <br><br>
			+ display: 디스플레이 속성을 변경 (inline, block, none[안보임] <br><br>
			<h4>
				#CSS에서의 주석처리 : /* 주석처리된 내용*/
			</h4>
			<h4>
				#디스플레이 Propoerty
			</h4>
			+ Block level element (tag) : 화면 전체를 쓰는 태그 ex) h1 <br><br>
			+ Inline element (tag) : 자신의 부피만큼만 쓴느 태그 ex) a 
			<h4>
				#중복의 제거
			</h4>
			<h5>
				두 Selector가 같은 효과가 적용되면 a,h1 {~} 로 처리 가능 <br> <br>
				Declaration에서 간편히 border : 5px solid red;로 처리가능
			</h5>
			<h5>
				CSS Box model 검색으로 여러 기능 알아보거나, 웹페이지 검사를 통해 알아볼 수 있다.
			</h5>
			<h3>
				8. 박스모델 써먹기
			</h3>
			<h4>
				#구현하고자하는 페이지를 위해서
			</h4>
			1. h1 seloector, width-bottom 을 적용 (아랫쪽만 테두리 형성) <br><br>
			2. 테두리와 너무 붙어있어, margin 값을 제거 (검사를 통한 추론) <br><br>
			3. padding 값을 줘서 간격을 만든다.<br><br>
			4. ol{ordered list} selector, width-right를 추가 <br><br>
			5. ol에 width를 줘서 간격 조정 <br><br>
			6. 그래도 간격이 너무 많아  ol의 margin을 제거 <br><br>
			7. 리스트들이 서로 붙어있어, padding을 줘서 거리두기를 시킨다. <br><br>
			8. 가장 바깥쪽의 여백이 많아 body태그의 margin을 0으로 한다. <br><br>
			
			<h3>
				9. 그리드
			</h3>
			<h4>
				#의미는 없지만, 디자인 용도(id나 class)를 위해 써먹는 태그
			</h4>
			1. &lt;div> &lt;/div> : Block level elemnet. <br><br>
			2. &lt;span> &lt;/span> : Inline elemenet. <br><br>
			
			div에 id를 준 후, style에서 {display : grid; grid-template-columns : 150px 1fr} : display를 grid로 바꾼다. 두 영역의 크기는 각각 150px과 1fr이다. <br> 1fr : 남은 자유 공간의 1/(총fr 지금 경우는 1) 
			<h4>
				<a href = "https://caniuse.com/" target = "_blank" title = "https://caniuse.com/ 바로 가기">https://caniuse.com/</a> : css, jsp, html 기술 중 얼마나 쓰고 있는지, 어떠한 웹브라우저에서 쓸 수 잇는 지 통계를 보여줌.
			</h4>
			<h3>
				10. 그리드 써먹기
			</h3>
			<h4>
				#구현하고자하는 페이지를 위해서
			</h4>
			<h5>
			1. 리스트와 본문을 그리드로 묶는다.
			</h5>
			+ 본문 h2와 p를 div(article)로 묶고 이를 다시 리스트와 div(grid)로 묶는다. <br><br>
			#grid {dislpay :grid; grid-template-columns : 150px 1fr;} <br><br>
			+ 리스트의 여백이 너무 커 padding left를 조정한다. (검사를 통해 마우스를 갖다대고 키보드 상하키로 미리 조정해보기가 가능)
			<h5>
				ol seloectotr은 다른 곳에서도 쓸 수 있으니 style에서 ol이 아닌 #grid ol로 바꾸어 준다 (id로 grid를 가진 ol)
			</h5>
			<h3>
				11. 반응형 디자인
			</h3>
			웹은 모든 시스템에서 사용하기에 수많은 화면에서 동작해야만 했다.
			따라서 여러 화면에 대응되는 웹을 만들기 위해 디자인되었다. 
			<br> => 화면의 크기에 따라 반응하여 동작하는 디자인
			<h4>
				screen width > 800px이면, div{display :none;}으로 바꾼다
				<br> @media(min-width: 800px)<br>
				{<br>
					div {dislpay : none;} <br>
				}
			</h4>
			+ media : media query를 의미 <br><br>
			+ min(or max) : 최소 혹은 최대 화면이 n일 때 까지 이 안의 코드가 작동한다.
			<h3>
				12. 미디어 쿼리 써먹기
			</h3>
			<h4>
				#화면이 800px이하일 때 작동시켜야할 기능들이 있다.
			</h4>
			<h5>
				grid를 없앤다.
			</h5>
			<h6>
				#grid {display : block; } : grid -> block
			</h6>
			<h5>
				세로 테두리를 없앤다.
			</h5>
			<h6>
				ol {border-right:none;} 
			</h6>
				가로 테두리를 없앤다.
			<h6>
				h1 {border-right:none;} 
			</h6>
			<h3>
				13. CSS 코드의 재사용
			</h3>
			
			<h4>
				style 태그에 적힌 코드들을 style.css파일에 옮긴다. <br> &lt;link rel = "stylesheet href = "/style.css"> 라고 있던 자리에 적어준다.
			</h4>
			<h5>
					+ 위 주소와 링크되어 웹브라우저는 위 주소를 다운받아서 링크로 연결한다. <br><br>
	+ 장점: n개의 각각 파일을 바꾸지 않고 1개의 파일만을 바꾸어 수정할 수 있으며 새로운 웹페이지에 한 줄만으로 시각적 기능을 사용 가능<br><br>
	+ -> 재사용성 증가 and 내부 원리 몰라도 사용 가능<br><br>
	+ 단점 : css파일을 추가로 다운로드 받아서, 네트워크 적인 측면에서 비효율적임 (그러나 캐시 기술로 인해, 많이 받다보면 효율적이 됨)<br><br>
			</h5>
			<h3>
				14. 수업을 마치며
			</h3>
			<h4>
				Property : 풍부한 표현이 가능
			</h4>
			<h4>
				Selector : 정확한 표현이 가능
			</h4>
			<h4>
				계속 배운 것을 사용해야 공부가 된다.
			</h4>
		</div>
	</div>
</body>
</html>